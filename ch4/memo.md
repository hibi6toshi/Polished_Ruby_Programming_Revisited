# メソッドと引数

## メソッド引数を使いこなす（4.3）

### 位置引数（4.3.1）

位置引数はメソッド引数の種類のデフォルトです。メソッド定義でローカル変数を宣言すると、それは位置引数になります。
メソッド引数が複数になると、引数の順番の問題が出てくる。

メソッドの引数順問題を回避する手段として、必須のキーワード引数を使うこともできます。

```
class Screen
  def draw_box(x1:, y1:, x2:, y2:); end
end
```

この方式ではメソッド引数のそれぞれをユーザーが明示的に指定できるので、メソッドの引数問題を避けられます。
しかし、これだと入力の手間を省きたいユーザーにも冗長な呼び出し形式を強制することになります。
どちらの形式でも呼び出せるようにする場合、以下のようにする。

```
class Screen
  def draw_box(_x1 = nil, _y1 = nil, _x2 = nil, _y2 = nil,
               x1: _x1, y1: _y1, x2: _x2, y2: _y2)
    raise ArgmentError unless x1 && y1 && x2 && y2
  end
end
```

この方式では、以下のように位置引数でもキーワード引数でも呼び出すことができるようになる。

```
screen.draw_box(0, 10, 0, 20)
screen.draw_box(x1: 0, x2: 0, y1: 0, y2: 20)
```

この方式の代償は 2 つある。
1 つ目は以下のように呼び出せてしまえること。

```
screen.draw_box(5, 30, 15, 40,
                x1: 0, x2: 0, y1: 0, y2:20)
```

引数が衝突しており、呼び出し意図が不明だが ArgumentError は発生しない。
2 つ目は、この方式の実行性能が明らかに劣ることです。実行性能が重視される局面で採用するのは避けましょう。

### オプショナル位置引数(4.3.2)

位置引数にはデフォルト引数を設定できます。デフォルト値を設定した位置引数は、必須ではなくオプショナルになります。ただし、この説明は完全に正確ではありません。
すべての位置引数をオプショナルにできるわけではないからです。

2 つの必須の位置引数に挟まれた位置引数はオプショナルにできます。

```
def a(x, y=2, z)
  [x, y, z]
end
a(1, 3)
# -> [1, 2, 3]
```

一方、2 つのオプショナル位置引数で必須の位置引数の前後を挟むことはできません。

```
eval(<<END)
  def a(x=1 , y, z=2)
  end
END
# 構文エラー
```

一般的に後続引数を使ったメソッドはあまり見かけません。メソッドでオプショナル位置引数を採用している場合、大抵は次のような形式になっています。

```
def a(x, y=nil)
end
```

逆のケースはほとんど見かけません。

```
def a(x=nil, y)
end
```

「オプショナル引数、後続引数」という引数順が役に立つ場面として想定できるものの 1 つは、「引数が 1 つまたは 2 つ渡せるメソッド呼び出し」を「2 番目の引数だけを指定したメソッド呼び出し」として扱いたい k 時ケースです。

具体例としては、SQL では識別子が完全修飾であってもなくても構いません。これを Ruby で表現したい場合、選択肢は 2 つあります。

```
def identifier(column, table=nil)
end

def identifier(table = nil, column)
end
```

ここでは後者の方が理にかなっているでしょう。「foo.bar」の識別子を得るためのメソッド呼び出しは、「identifier('bar', 'foo')」より「identifier('foo','bar')」の方が概念的にシンプルだからです。

### 可変長引数（4.3.3）

Ruby のメソッド引数で可変長引数を配置できるのは、1 つのメソッド定義につき 1 回だけです。可変長引数に格納されるのは、メソッドが呼び出された時点で先導引数、オプショナル引数、後続引数のいずれとしても処理されなかった残りの位置引数の全てです。可変長引数では引数名を省略できることです。

```
def foo(bar, *)
end
```

この形式は引数を無視したい場合に使えますが、もしその必要があるとしたら、ほぼ必ずメソッド設計が残念な状態になっています。引数名の指定の省略を有効活用できそうな唯一のケースは、「super を引数なしで呼び出して、メソッドに渡された引数をそっくりそのまま受け渡す場合」ぐらいです。

```
def foo(bar, *)
  bar = 2
  super
end
```

可変長引数は他の位置引数と組み合わせて使えます。
よくあるケースは、先導引数と可変長引数という組み合わせです。

```
def a(x, *y)
end
```

```
def a(x, y=nil, *z)
end
```

ただし、この形式には「不吉なコードの臭い」がすることがあります。
合理的だと断言できるケースはあるにはあるが、後方互換性のためにどうしても必要だというのではない限り、できるだけ避けるべきです。
後続引数であれば、可変長引数と組み合わせることができます。

```
def a(*y, z)
end
```

この形式はかなり稀ですが、有用な場面はあります。例えば mv コマンドに似た API の提供に取り組んでいるとします。
mv の引数として、通常は「移動元」と「移動先」の 2 つを指定しますが、他にも「任意の数の移動元」と「単一の移動先フォルダ」を指定するといった使い方もあります。
それならば、この API でも「必ず 2 つ以上の引数が渡される」ようにしたいところです。複数の移動元を可変長引数で、移動先を後続引数を使って表現すれば、Ruby でもこの API を再現できます。

```
def mv(source, *sources, dir)
  sources.unshift(source)
  sources.each do |source|
    move_into(source, dir)
  end
end
```

これで「2 つ以上の引数が渡される」という API を実現できます。

```
mv("foo", "dir")
mv("foo", "bar", "baz", "dir")
```

### キーワード引数（４.３.４）

キーワード引数の指定は任意とすることが多いので、引数のデフォルト値としてハッシュがよく使われます。

```
def foo(options={})
end
```

Ruby2.0 からメソッド定義でキーワード引数が使えるようになりました。

```
def foo(bar: nil)
end
```

メソッド定義で使えるキーワード引数には素晴らしい特徴があります。メソッド呼び出し時にハッシュを生成しないので、実行性能が向上するのです。

```
# ハッシュは生成されない
foo
foo(bar: 1)

# これはハッシュが生成される
hash = {bar: 1}

# Ruby3.0 では、キーワード変数を展開してもハッシュは生成されない
foo(**hash)
```

重要な改善点は、想定外のキーワードを引数に渡すとエラーになることです。

```
foo(baz: 1)
# unknown keyword: :baz (ArgumentError)
```

Ruby3.0 では位置引数とキーワード引数は独立してある買うことができる。

```
def foo(*args, **kwargs)
  [args, kwargs]
end

# キーワードがキーワードとして扱われている。
foo(bar: 1)
# -> [[], [bar: 1]]

# ハッシュは位置引数として扱われる
foo({bar: 1})
# -> [[{:bar=>1}], {}]
```

新しく書くコードでは、オプショナル位置引数にはハッシュではなくキーワード引数を使うのが良い。新しく定義するメソッドで考慮が必要になるのは「そのメソッドではキーワード引数を無視したいかどうか」です。無視したい場合は「\*\*nil」という構文を使って「キーワード引数を無視する」という印をつけます。

```
def foo(bar, **nil)
end
```

この構文が導入された理由は、「後になって、キーワードが追加されたことが原因でメソッドが動かなくなる」ことを防ぐためです。例えば、「\*\*nil」を使わずにメソッドを定義するとします。

```
def foo(bar)
  bar
end
```

メソッドの呼び出しで、キーワード記法を使えます。

```
foo(bar: 1)
# -> {:bar => 1}
```

このメソッドはキーワード引数を受け付けていないので、引数がキーワード記法で渡された場合、渡された引数は Ruby により「位置引数のハッシュ」へと変換されます。これは、位置引数を受け取る既存コードとの後方互換性のためです。このメソッドにキーワード引数を追加するとどうなるでしょうか。

```
def foo(bar, baz: nil)
  bar
end
```

メソッド呼び出しが壊れてしまいます。

```
foo(bar: 1)

`foo': wrong number of arguments (given 0, expected 1) (ArgumentError)
```

foo メソッドがキーワード引数を受け取るように変更されたので、Ruby は「キーワード引数から位置引数のハッシュへの変換」を止めます。これが ArgumentError 例外の原因です。この問題を回避するには、この新しいメソッドの定義で「\*\*nil」構文を使います。

```
def foo(bar, **nil)
  bar
end
```

これはキーワード変数を受け付けないことを表しています。
こうしておけば、キーワードを後から追加しても呼び出し側が壊れることは無くなります。そもそもまだメソッドにキーワード引数を追加されていない状態であっても、ユーザーがこのメソッドをキーワードを使って呼び出すと ArgumentError 例外が発生します。

```
foo(bar: 1)
no keywords accepted (ArgumentError)
```

### ブロック引数（4.3.5）

ブロックはシンプルな構文のおかげでメソッドに簡単に渡せます。return でブロックのスコープから呼び出し元に復帰できますし、next や break を使えば現在のブロックチェーンから抜け出せます。

後方互換性を保ったままブロック引数の振る舞いを変えることは不可能ではありませんが、新しい振る舞いで動作させるために、キーワード引数のような別の引数が必要になります。例えば、yield する際のブロックパラメーターとしてメソッドに渡された引数とレシーバーのインスタンス変数を使っているとします。

```
def foo(bar)
  yield(bar, @baz)
end
```

呼び出し側の例を示します。

```
foo(1) do |bar, baz|
  bar + baz
end
```

後になって、例えば「別のインスタンス変数の値もブロックパメーターとして渡すともっと使いやすくなる」ことが判明したとします。

```
def foo(bar)
  yield(bar, @baz, @initial || 0)
end
```

これなら呼び出しは以前と変わらない形式で呼び出せます。

```
foo(1) do |bar, baz|
  bar + baz
end
```

これが動作するのは、ブロックは追加されたブロックパラメーターを無視するからです。
追加されたブロックパラメーターを使うこともできます。

```
foo(1) do |bar, baz, initial|
  bar + baz
end
```

残念ながら、このメソッド定義の変更は完全な後方互換ではありません。通常のぶろくについては正しく動作しますが、変更前の API を想定している lambda を渡すと動かなくなります。

```
adder = -> (bar, baz) do
  bar + baz
end

# 以前は動いていたが、壊れてしまう。
foo(1, &adder)
```

lambda はアリティの扱いが厳格です。ユーザーが lambda をブロック引数として渡せるケースでは、ブロックパラメーターの数を安全に変更することはできません。先ほどのサンプルコードで安全な変更を実現するには、新しい振る舞いを有効にするための仕掛けが必要です。ここではキーワード引数を使って実装するのが良いでしょう；

```
def foo(bar, include_initial: false)
  if include_initial
    yield(bar, @baz, @initial || 0)
  else
    yield(bar, @baz)
  end
end
```

この方法は安全ではありますが、メソッドを呼び出す側とメソッドをメンテナンスしていく側のいずれにとっても複雑性が増しています。別の対応策として渡されたブロックのアリティに応じてブロック引数の扱いを変えることもできます。

```
def foo(bar, &block)
  case block.arity
  when 2, -1, -2
    yield(bar, @baz)
  else
    yield(bar, @baz, @initial || 0)
  end
end
```

こちらの方が呼び出し側にとっては観点になります。

ブロックパラメーターを変更したくなった場合には、このセクションで紹介したキーワード引数で対応する方法や、ブロック引数でアリティを検査する方法よりも、新しく別のメソッドを定義することでブロック引数の用途を刷新することを真剣に検討しましょう。

## 委譲の使い方（４.５）

### 他のオブジェクトに移譲する（４．５．１）

Forwardable を使うと、クラスに自前でメソッドを定義しなくても委譲を実現できます。

```
require 'forwardable'

class A
  extend Forwardable
  def_delegators :b, :foo
end
```

Forwadable モジュールはとても柔軟です。処理の委譲先としてインスタンス変数や定数も指定できます。

```
class A
  extend Forwardable
  def_delegators :@b, :foo
  def_delegators "A::B", :foo
end
```

forwadable の主な利点は、委譲するメソッドを一度にまとめて指定できることです。

```
class A
  extend Forwardable
  def_delegators :b, :foo, :bar, :baz
end
```
